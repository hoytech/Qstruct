=encoding utf-8

=head1 NAME

Qstruct - Quick structure serialisation

=head1 SYNOPSIS

    use Qstruct;

    ## Parse and load schema
    Qstruct::load_schema(q{
      ## This is my qstruct schema

      qstruct MyPkg::User {
        id @0 uint64;
        is_admin @2 bool;
        name @1 string;
        account_ids @3 uint64[];
      }
    });

    ## Build a new user message
    my $user_builder = MyPkg::User->build;
    $user_builder->set_id(100);
    $user_builder->set_name("jimmy");
    $user_builder->set_is_admin(1);
    my $encoded_data = $user_builder->finish;

    ## Load a user message and access fields
    my $user = MyPkg::User->load($encoded_data);
    print "User id: " . $user->get_id . "\n";
    print "User name: " . $user->get_name . "\n";
    print "*** ADMIN ***\n" if $user->get_is_admin;

    ## Zero-copy access of strings/blobs
    $user->get_name(my $name);
    print "User name: $name\n";


=head1 DESCRIPTION

B<Qstruct> is a data serialisation format. Unlike L<JSON|http://json.org>, L<Storable>, L<Sereal>, etc, Qstruct requires a schema. This makes it more like L<XML>, L<ASN.1|http://www.itu.int/en/ITU-T/asn1/Pages/introduction.aspx>, or L<Protocol Buffers|https://developers.google.com/protocol-buffers/>.

Qstruct is heavily inspired by L<Cap'n Proto|http://kentonv.github.io/capnproto/> and I am indebted to Kenton Varda for thinking through a lot of the details of how this type of serialisation should work. Qstructs originally came about as an attempt to implement Cap'n Proto in perl.


=head1 GOALS

The goal of Qstruct is to provide as close as possible performance to C C<struct>s -- even including pointers inside structs -- while also being portable, extensible, and safe. The way it does this is by making the "in-memory" representation the same as the "wire" format. Because it's redundant to distinguish between these formats, this documentation will only refer to I<the> Qstruct format.

C<Portable>: Although all integers and floating point numbers are stored in little endian and can start at unaligned offsets (if you load from them), Qstructs can be used on any CPU, even if it is big endian or has strict alignment requirements.

C<Extensible>: New fields can be added to the structure as needed without invalidating already created messages. The fields can be renamed or jumbled around in any order as long as you don't change the types or C<@> ids of existing fields.

C<Safe>: Accessing data from untrusted sources should never cause the program to read or write out of bounds causing a segfault or worse. The format is quite simple so that verifying and testing should be straightforward. There will be a canonicalisation protocol so Qstructs should be cache-friendly and suitable for digitally signed messages.



=head1 SCHEMA LANGUAGE

The schema language is modeled very closely after Cap'n Proto's although it is much simpler.

A schema is a series of qstructs. Each qstruct contains 0 or more fields. Each field is 3 items: The name, the C<@> id, and the type specifier.

Whitespace is insignificant and C and perl-style comments are allowed.

For example, here is a schema:

      qstruct User {
        id @0 uint64;
        active @4 bool;
        name @2 string;
        email_addrs @3 string[]; # dynamic, pointer-based
        sha256_checksum @1 uint8[32]; # fixed, inline
      }

      qstruct Junk {
        /* There can be multiple qstructs in a schema
         * And this one is... empty!
         */
      }


=head1 TYPES

=over 4

=item  int

A family of types the differ in size and signedness: C<int8>, C<int16>, C<int32>, C<int64>, C<uint8>, C<uint16>, C<uint32>, C<uint64>.

Always stored in little-endian byte order (even in-memory on big-endian machines).

Default: 0

=item  float/double

IEEE-754 floating point numbers in little-endian byte order. C<float> and <double> both consume and are aligned at 4 and 8 bytes respectively.

Default: 0.0

=item  boolean

A single-bit "flag". This is the only type where values can be packed together inside a single-byte.

Default: 0 (false)


=item  string/blob

A pointer and a size referring to a later part of the message. They consume at least 16 bytes each. The only difference between C<string>s and C<blob>s is that blobs are aligned at FIXME bytes and are therefore suitable for maintaining alignment of nested qstructs.

Strings and blobs are both considered arbitrary sequences of bytes and neither type enforces any character encoding. I don't believe it is necessary for (or even the place of) a serialisation format to dictate encoding policy. Of course you are free to enforce/assume a common encoding for all of I<your> messages.

Qstruct strings can take advantage of a space optimisation called B<tagged-sizes>. This is essentially the only "clever" packing trick in the Qstruct format. Because the alignment of strings doesn't matter and because 64 bit sizes give us heaps of room to work with, string sizes are encoded specially. If the lower nibble of the first byte is zero then the whole 64-bit size is bit-shifted down 8 bits. This is then taken to be the size of whatever the pointer is pointing to. If the lower nibble of the first byte was instead non-zero, this is taken to be an inline length and the pointer is ignored: Instead the string is located at the following byte. Note that only strings of 15 or fewer bytes can be size-tagged. Blobs can never use tagged-sizes because of their alignment requirements.

Default: '' (Empty string)


=back





=head1 FORMAT

=head2 MESSAGE

A message is a block of data representing a Qstruct. It is either in the process of being built or is ready-only and ready to be accessed.

The message data should be considered a binary blob and it may contain NUL bytes so its length must be tracked separately (ie not a terminating NUL).

Messages can in theory be any size representable in an unsigned 64 bit number. However, on 32-bit machines some messages are too large to access and attempting to build or load these messages will throw exceptions.

Messages are not self-delimiting so when transmitting them they need to be framed in some fashion. For example, when sending across a socket you might choose to send an 8-byte little-endian integer before the message data to indicate the size of the message that follows.


=head2 HEADER

All Qstructs start with a 16 byte C<header>. The first 8 bytes are reserved and should always be 0s. The second 8 bytes is a little endian unsigned 64-bit integer that indicates how large the following C<body> is (which may be shorter than the total message size).

    00000000  00 00 00 00 00 00 00 00  15 2f 00 00 00 00 00 00
              |--reserved (all 0s)--|  |body size (LE uint64)|

The reserved bytes are there for future extensions such as schema versioning.



=head2 BODY

The body immediately follows the header. Its exact format depends on the C<schema> that is used to access it. For example, consider the following schema:

    qstruct User {
      id @0 uint64;
      is_admin @1 bool;
      name @2 string;
      is_locked @3 bool;
    }

Suppose we create a user with the following data:

    $user->set_id(100);
    $user->set_name("hello world!");
    $user->set_is_admin(1);
    $user->set_is_locked(1);

This would be the resulting format:

    00000000  00 00 00 00 00 00 00 00  20 00 00 00 00 00 00 00  |................|
              |---------------------header-------------------|

    00000010  64 00 00 00 00 00 00 00  03 00 00 00 00 00 00 00  |d...............|
              |--------id (@0)------|  || |----free space----|
                                       ||
                                       |->is_admin/is_locked (@1/@3)

    00000020  0c 68 65 6c 6c 6f 20 77  6f 72 6c 64 21 00 00 00  |.hello world!...|
              || |--------inline string data--------| |--pad-|
              ||
              |-> name (@2) tag byte indicating length of inline string


When computing the body offsets, the Qstruct compiler will always try to find the first location in the message that data type will fit into while still respecting the alignment preference of the data types. In this fashion it works like a first-fit memory allocator. If no gaps can be found, it will append the type onto the end of the message (possibly prepending some free space to respect alignment).




=head1 ARRAYS



=head1 ZERO-COPY



=head1 PORTABLE

This module uses the "slow" but portable accessors described in L<libqstruct|https://github.com/hoytech/libqstruct>'s docs so it should work on any machine regardless of endianess or alignment requirements. These accessors are not actually slow relative to the overhead of making a perl function or method call.


=head1 EXTENSIBLE

As long as you don't change existing fields' types or C<@> ids, you can always add new fields to a qstruct and any messages that were created with the old schema will still be loadable. Accessing the new fields of these old messages will return the particular types' default values.

You can change the name of any field as long as you don't change the C<@> id.

The order of the fields in a struct are irrelevant -- only the types and C<@> ids influence the packing order. Similarly, comments can be added/removed anywhere.

You can change the signedness of integer types as long as you are OK with effectively re-casting the data (ie negative ints become large positive ints/large positive ints become negative ints).

You can change a blob to a string (if you are willing to change the canonicalisation) but you can't change a string to a blob due to alignment.


=head1 SAFETY

=head2 SAFETY OF SCHEMA PARSING

Do not process schemas from potentially malicious sources. There are trivial memory consumption attacks possible. That said, the ragel finite state machine parser is very precise so there should be no code-execution attacks possible.

=head2 SAFETY OF LOADING/ACCESSING

If you use the wrong schema or the message has been corrupted by a malicious attacker then there should be no possibility of a segfault or reading/writing out of bounds. However, the message data will be garbage (but malicious messages could encode garbage data anyway).

When loading or accessing a message there should be no way to make this module consume any more memory than you explicitly copy out of it. In any one operation this will be at most the size of the message. With zero-copy accessors none of the message data is copied at all.

Unlike Cap'n Proto, the simplistic nature of the Qstruct format does not explicitly provide list-like/tree-like/nested data-structures so there is nothing to configure in the Qstruct implementation to prevent stack overflows, cycles, or recursion. Note that you can manually traverse nested Qstructs inside blobs (or arrays of blobs).


=head1 CANONICALISATION

This is not implemented yet but, subject to some constraints I will document here, messages can be efficiently converted into a canonical form. The C<copy> method will return a canonicalized version of the message.

There is a lot to think about for this -- don't rely on it for security until this is all fleshed out: All pointers must point forward when traversed in a particular order. Null out all free and unallocated space. Make sure tagged-size optimisation is always applied when possible. Null out high bytes and high nibble in tagged-sizes. Ensure no trailing nul bytes on body (these are always assumed to be 0 anyway). Ensure no extra padding on end of message. Null out reserved area. Ensure only 2 representations for NaN (qNaN/sNan).



=head1 SEE ALSO

L<Qstruct github repo|https://github.com/hoytech/Qstruct>

L<libqstruct github repo|https://github.com/hoytech/libqstruct>

=head1 AUTHOR

Doug Hoyte, C<< <doug@hcsw.org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2014 Doug Hoyte.

This module is licensed under the same terms as perl itself.

The bundled C<libqstruct> is (C) Doug Hoyte and licensed under the 2-clause BSD license.
