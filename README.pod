=encoding utf-8

=head1 NAME

Qstruct - Qstruct perl interface

=head1 SYNOPSIS

    use Qstruct;

    ## Parse and load schema
    Qstruct::load_schema(q{
      ## This is my schema

      qstruct MyPkg::User {
        id @0 uint64;
        name @1 string;

        is_admin @3 bool;
        is_moderator @4 bool;

        emails @2 string[];
        account_ids @5 uint64[];

        sha256_hash @6 uint8[32];
      }

    });

    ## Build a new user message:
    my $message = MyPkg::User->encode({
                    name => "jimmy",
                    id => 100,
                    is_admin => 1,
                    emails => ['jimmy@example.com', 'jim@jimmy.com'],
                    sha256_hash => "\xFF"x32,
                  });

    ## Load a user message:
    my $user = MyPkg::User->decode($message);

    print "User id: " . $user->id . "\n";
    print "User name: " . $user->name . "\n";
    print "*** ADMIN ***\n" if $user->is_admin;

    ## Zero-copy access of strings/blobs
    $user->name(my $name);


=head1 DESCRIPTION

B<Qstruct> is a binary serialisation format that requires data schemas and this is the dynamic-language reference implementation in perl.

L<Qstruct::Spec> is specification for the qstruct format. Because in qstructs the "wire" and "in-memory" formats are the same, the C<encode> and C<decode> functions are somewhat mis-named. As soon as the object is built in memory, it is ready to be copied out to disk or the network, and as soon as it is read or mapped into memory it is ready for accessing.

This module is designed to be particularly efficient for "decoding" qstructs. Strings, blobs, and arrays can all be randomly accessed or iterated over without reading or parsing any unrelated parts of the message. Furthermore, these types can be mapped in a zero-copy manner where the message data is never copied -- only pointers into the message are recorded.

The encoder in this module is not slow per-se, it just does more memory-allocations and copying than an optimised implementation would. The compiled static interface will probably be optimised for encoding eventually.



=head1 ZERO-COPY

As shown in the synopsis, fields can be accessed simply by calling their corresponding methods on the objects representing decoded messages:

    ## Field access (copying)

    my $name = $user->name;

However, due to the semantics of return values in perl, the above line of code allocates new memory and copies the C<name> field into it which can be inefficient for several reasons.

Firstly, copying takes time and this time is proportional to how large the data is. If it's really large and/or you only need to access a small part of it, then copying can be wasteful.

Secondly, zero-copy is efficient because it minimises the impact on your memory system. If you aren't copying the data, you aren't paging it in from disk, putting it into your filesystem or CPU caches, pushing other things out of caches, or impacting your CPU's translation lookaside buffer (TLB).

Qstruct is always B<lazy> when it comes to memory access: It will only access the bare-minimum memory required to fulfill accessor requests.

If you wish to avoid copying, you need to pass an "output" scalar into the accessor method:

    ## Field access (zero-copy)

    $user->name(my $name);

Passing these "output" scalars into methods is a common theme throughtout the L<Qstruct> perl module.

For more information on zero-copy, see the L<Test::ZeroCopy> module and the C<t/zerocopy.t> test in this distribution that uses it.

This module is designed to work with modules like L<File::Map> which map files into perl strings without actually copying them into memory and also L<LMDB_File> which is a transactional in-process data-base that has zero-copy interfaces also.

With these modules you can have true zero-copy access to data in the filesystem from your high-level perl code just as conveniently as most copying interfaces.



=head1 ARRAYS

When you call the accessor method on an array it returns a special overloaded object of type C<Qstruct::ArrayRef>. This object can (as you might guess) be accessed as an array reference:

    ## Array random access (copying)

    my $first_email = $user->emails->[0];


Because of the lazy-loading nature of Qstructs, none of the other elements will be accessed at all. If the message is in a memory-mapped file the other elements might never even get paged in to memory.

Of course references can also be de-referenced and iterated over:

    ## Array iteration (copying)

    foreach my $email (@{ $user->emails }) {
      print "email: $email\n";
    }

But C<Qstruct::ArrayRef> are actually special objects that have methods. The problem with the above approach is that while the elements are lazy-loaded, they are not zero-copy, in other words new memory is being allocated for them by perl and then they are copied into this new memory.

L<Qstruct> provides another interface that avoids these copies, the C<get> method:

    ## Array random access (zero-copy)

    $user->emails->get(0, my $first_email);

Because the C<my $first_email> scalar is passed in, the C<get> method will populate it with a pointer into the underlying message-memory owned by the C<$user> object.

There is also a C<len> method which of course means you can iterate over arrays:

    ## Array iteration (zero-copy)

    my $emails = $user->emails;
    for(my $i=0; $i < $emails->len; $i++) {
      $emails->get($i, my $email);
      print "Email: ", $email, "\n";
    }

There is actually a short-cut C<foreach> method that simplifies the above pattern:

    ## Array iteration short-cut (zero-copy)

    $user->emails->foreach(sub {
      print "Email: ", $_[0], "\n";
    });



=head1 RAW ARRAY ACCESS

For the numeric types there are also raw accessors. For example, hash values are known-fixed lengths so it sometimes might make sense for them to be fixed arrays (see L<Qstruct::Spec> for details) which are inlined in the message body for efficiency. Such arrays are most likely best accessed with raw accessors:

    ## Whole-array access (copying)

    my $hash_value = $user->sha256_hash->raw;

Of course there is a corresponding zero-copy interface:

    ## Whole-array access (zero-copy)

    $user->sha256_hash->raw(my $hash_value);

When encoding messages, you can simply pass in an appropriately sized string and it will be treated as raw:

    my $msg = MyPkg::User->encode({
      sha256_hash => Digest::SHA::sha256("whatever"),
    });

Dynamic arrays can also be accessed with the same raw accessors:

    $user->account_ids->raw(my $array_of_account_ids_as_a_buffer);

Since C<account_ids> is of type C<uint64[]>, the above variable will be a buffer of C<8 * N> bytes where N is the (dynamic) number of account ids stored.

Note that numeric values are stored in little-endian format so if you use raw accessors on arrays with elements of more than 2 byte sizes you will need to C<unpack> them in order for your code to be portable.


=head1 EXCEPTIONS

This module will throw exceptions on errors. The following conditions will throw exceptions:

    * Schema parse errors
    * Out of memory during encoding
    * You are on a 32-bit system and you attempt to access
      a field that can't fit in your address space
    * Accessing truncated/malformed qstructs

Note that when fields aren't set, accessing them will I<not> throw exceptions. Instead, it will return the default values of their respective types (see L<Qstruct::Spec>). This is even true of old messages that were created with old versions of the schema before the field was defined.


=head1 PORTABILITY

This module uses the "slow" but portable accessors described in L<libqstruct|https://github.com/hoytech/libqstruct> meaning it should work on any machine regardless of byte order or alignment requirements. Despite the name, these accessors are not actually slow relative to the overhead of making a perl function or method call.

Because the perl module uses the slow and portable accessors, no matter what CPU you use you do not need to ensure that you load messages from aligned offsets. When using the C API, if you choose to compile with the non-portable accessors you should be aware that depending on your CPU you may have reliabilty or performance issues if you load messages from non-aligned offsets. However, on modern intel x86-64 CPUs you can use the "fast" interface and not sacrifice reliability or performance even when accessing non-aligned messages.



=head1 SEE ALSO

L<Qstruct::Spec> - The Qstruct design objectives and format specification

L<Qstruct::Compiler> - The perl module reference compiler-implementation

L<libqstruct|https://github.com/hoytech/libqstruct> - Shared C library

L<Qstruct github repo|https://github.com/hoytech/Qstruct>


=head1 AUTHOR

Doug Hoyte, C<< <doug@hcsw.org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2014 Doug Hoyte.

This module is licensed under the same terms as perl itself.

The bundled C<libqstruct> is (C) Doug Hoyte and licensed under the 2-clause BSD license.


=cut

